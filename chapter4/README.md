# 第4章 变量、作用域和内存问题

## 4.1 基本类型和引用类型的值

ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。 

基本数据类型： Undefined、 Null、 Boolean、 Number 和 String、BigInt、Symbol。这 7 种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值。

引用类型Object的值是保存在内存中的对象。与其他语言不同， JavaScript 不允许直接访问内存中的位置，实际上是在操作对象的引用。Object 派生出来的结构类型：new Object，new Array，new Map，new Set，new WeakMap，new WeakSet，new Date，几乎所有通过 new keyword 创建的东西。

### 4.1.1 动态的属性
对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法。

**扩展问题：是否可以给基本类型的值添加属性呢？[示例](./4.1/DynamicPropertiesExample02.html)**

### 4.1.2 复制变量值
当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到
为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在**堆**中的一个对象。

```javascript
var obj1 = new Object();
var obj2 = obj1;
obj1.name = "Nicholas";
alert(obj2.name); //"Nicholas"
```

例子当中obj1 和 obj2 都指向同一个对象。obj1添加属性，obj2也可访问到。

### 4.1.3 传递参数
ECMAScript 中所有函数的参数都是按值传递的。像复制变量一般，见[示例](./4.1/FunctionArgumentsExample01.html)

**注：函数的参数是局部变量**

### 4.1.4 检测类型
typeof 操作符是确定一个变量是字符串、数值、布尔值，还是 undefined 的最佳工具。

typeof无法区分对象类型，当变量是null或是对象，都会返回object。那么我们可以使用instanceof[示例](./4.1/DeterminingTypeExample02.html)，语法：result = variable instanceof constructor

## 4.2 执行环境及作用域
执行环境（execution context，也称为“环境”）是 JavaScript 中最为重要的一个概念，其定义了变量或函数有权访问的其他数据。

**全局执行环境：** 最外围的一个执行环境。在 Web 浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window 对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境被销毁通常——例如关闭网页或浏览器）。

**函数的执行环境：** 当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 

**作用域链（scope chain）：** 当代码在一个环境中执行时，会创建变量对象的一个作用域链。用途：保证对执行环境有权访问的所有变量和函数的有序访问。

### 4.2.1 延长作用域链
虽然执行环境的类型总共只有两种——全局和局部（函数），但还是有其他办法来延长作用域链。
这么说是因为有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。在两种情况下会发生这种现象。具体来说，就是当执行流进入下列任何一个语句时，作用域链就会得到加长：[示例](./4.2/ExecutionContextExample03.html)

### 4.2.2 没有块级作用域
JavaScript 没有块级作用域经常会导致理解上的困惑（不包括函数，JavaScript函数作用域是存在的）。在其他类 C 的语言中，由花括号封闭的代码块都有自己的作用域。

如果有块级作用域，if语句执行完毕后，变量color会被销毁。
但在JavaScript当中，变量声明会添加到最近的执行环境，在实例中是全局环境。

```javascript
if (true) {
var color = "blue";
}
alert(color); //"blue"
```

这样会导致变量的污染和资源的浪费，所以在ES6当中新增的声明方式：`let`，声明的变量只在所在的代码块内有效。

#### 1. 声明变量
var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境；在 with 语句中，最接近的环境是函数环境。如果初始化变量时没有使用 var 声明，该变量会自动被添加到全局环境。如下所示：[示例](./4.2/ExecutionContextExample04.html)

#### 2. 查询标识符
当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索作用域链来确定该标识符所在环境实际的值。（标识符：通常是可以自主命名的符号，例如：变量名、函数名、属性名等）[示例](./4.2/ExecutionContextExample06.html)


## 4.3 垃圾收集
JavaScript 内存的分配以及回收内存是自动管理。垃圾收集机制的原理：找出那些不再继续使用的变量，然后释放其占用的内存。

垃圾收集器必须跟踪变量，对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异，但具体到浏览器中的实现，则通常有两个策略：

### 4.3.1 标记清除
JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，当环境中的变量已经无法访问到这些变量了，环境中的变量已经无法访问到这些变量了。

### 4.3.2 引用计数
不太常见的垃圾收集策略叫做引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。

当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。

Netscape Navigator 3.0 是最早使用引用计数策略的浏览器，缺点是循环引用会导致无法回收内存，例子：
```javascript
function problem(){
  var objectA = new Object();
  var objectB = new Object();

  objectA.someOtherObject = objectB;
  objectB.anotherObject = objectA;
}
```

### 4.3.4 管理内存
数据不再有用，最好通过将其值设置为 null 来释放其引用——这个
做法叫做 **解除引用（dereferencing）** 。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用，如下面这个例子所示：

```javascript
function createPerson(name){
  var localPerson = new Object();
  localPerson.name = name;
  return localPerson;
}

var globalPerson = createPerson('Nicholas');

globalPerson = null;//手工接触globalPerson的引用
```

不过，解除一个值的引用并不意味着自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。